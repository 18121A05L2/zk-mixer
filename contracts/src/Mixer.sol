// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import {IVerifier} from "./IVerifier.sol";
import {IncrementalMerkleTree} from "./IncrementalMerkleTree.sol";

contract Mixer is IncrementalMerkleTree {
    IVerifier immutable i_verifier;
    uint256 public constant ETH_DENOMINATION = 0.0001 ether;

    mapping(bytes32 => bool) public commitments;
    mapping(bytes32 => bool) public s_nullifierHashes;

    error Mixer_CommitmentAlreadyExists();
    error Mixer_WrongDepositAmount();
    error Mixer_InvalidRoot();
    error Mixer_DoubleSpendingNotPossible();
    error Merkle_AuthenticationFailed();

    event Deposit(bytes32 _commitment, uint256 _leafIndex, address user);

    constructor(IVerifier _verifier, uint8 _depth, address _poseidon) IncrementalMerkleTree(_depth, _poseidon) {
        i_verifier = _verifier;
    }

    /// @notice Deposit tokens into the contract
    /// @param _commitment the poseidon commitment of the nullifier and secret ( generated using the circuit - off chain )
    function deposit(bytes32 _commitment) external payable returns (bool) {
        // check if commitment already exists , so that we can prevent double spending
        if (!commitments[_commitment]) revert Mixer_CommitmentAlreadyExists();
        if (msg.value != ETH_DENOMINATION) revert Mixer_WrongDepositAmount();

        // adding this to the Incremental Merkle Tree Data structure
        uint256 insertedLeafIndex = insert(_commitment);

        commitments[_commitment] = true;
        emit Deposit(_commitment, insertedLeafIndex, msg.sender);
        return true;
    }

    /// @notice Withdraw tokens from the contract
    /// We are not passing commitment here because, if we pass that one can know the deposit address using the commitment
    /// @param _proof the proof generated by the circuit
    function withdraw(bytes32 _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient)
        external
        returns (bool)
    {
        // need to check the root is valid or not
        if (s_root != _root) revert Mixer_InvalidRoot();

        // need to check whether the nullifier has been used to prevent the double spending
        if (s_nullifierHashes[_nullifierHash]) revert Mixer_DoubleSpendingNotPossible();

        bytes32[] memory publicInputs = new bytes32[](3);
        publicInputs[0] = _root;
        publicInputs[1] = _nullifierHash;
        publicInputs[2] = bytes32(uint256(uint160(address(_recipient))));

        // need to check if the proof is valid with verifier contract
        if (!i_verifier.verify(_proof, publicInputs)) revert Merkle_AuthenticationFailed();
        return true;
    }
}
