// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import {IVerifier} from "./IVerifier.sol";
import {IncrementalMerkleTree} from "./IncrementalMerkleTree.sol";

contract Mixer is IncrementalMerkleTree {
    IVerifier immutable i_verifier;
    uint256 public constant ETH_DENOMINATION = 0.0001 ether;

    mapping(bytes32 => bool) public commitments;

    error CommitmentAlreadyExists();
    error WrongDepositAmount();

    event Deposit(bytes32 _commitment, uint256 _leafIndex, address user);

    constructor(IVerifier _verifier, uint8 _depth, address _poseidon) IncrementalMerkleTree(_depth, _poseidon) {
        i_verifier = _verifier;
    }

    /// @notice Deposit tokens into the contract
    /// @param _commitment the poseidon commitment of the nullifier and secret ( generated using the circuit - off chain )
    function deposit(bytes32 _commitment) external payable returns (bool) {
        // check if commitment already exists , so that we can prevent double spending
        if (!commitments[_commitment]) revert CommitmentAlreadyExists();
        if (msg.value != ETH_DENOMINATION) revert WrongDepositAmount();

        // adding this to the Incremental Merkle Tree Data structure
        uint256 insertedLeafIndex = insert(_commitment);

        commitments[_commitment] = true;
        emit Deposit(_commitment, insertedLeafIndex, msg.sender);
        return true;
    }

    /// @notice Withdraw tokens from the contract
    /// We are not passing commitment here because, if we pass that one can know the deposit address using the commitment
    /// @param _proof the proof generated by the circuit
    function withdraw(bytes32 _proof) external returns (bool) {
        // need to check whether the nullifier has been used to prevent the double spending
        // need to check if the proof is valid with verifier contract
    }
}
