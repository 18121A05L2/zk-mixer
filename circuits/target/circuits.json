{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"16976098110482118130","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifierHash","type":{"kind":"field"},"visibility":"public"},{"name":"receipient","type":{"kind":"field"},"visibility":"public"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proofs","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"pdfbjuIwDAbgd+k1F7ET5zCvslqhAmVUqSqoAyOt0Lz7BvjNYaVULLmyofgjTZxAT82mWx0/l/243X01H79OzWrqh6H/XA67dXvod2N+9/SzaPTl8jB1XX6rebieq/bt1I2H5mM8DsOi+W6H4+VDX/t2vMRDO+WrZtF04ybHDG77oTtnP4t7tSmXWutQbKO7lctzPc3UC6Pekb/Xx6d6LtczxwSAreGSYMsCkdchEEV5ZwyBvI4hWFMSZGYMIVgdQ0jFu/BlITkBkHLR/9eT4dssGC/v3EMyuhKUuHgPM73kvDaiPK7kP71kKpuJZrqRfdQhsE+2SMw0A9n7NFguLgXZyrWcnYcUb/Mgb83Dax1NvrqlKVT35OwoqptSSBdDpHjAzdR71vqnhnqu57m1MHrCMj0MgF4H7G0thd8BHs74EIuAqz3kpfqUZ19/zEv1ruBYvSs4VZ4Oc8CL22r2Nqq3VTA6lcE+n/W/86t23U9P/3QaNs1HHhDTNfA12Pz95+gQ5bxdcvS553JDc0CMiOkarUEkREa0iA5REOFZeBaehefgOXgOnoPn4Dl4Dp6D5+A5eAJP4Ak8gSfwBJ7AE3gCT+B5eB6eh+fheXgenofn4Xl4Hl6AF+AFeAFegBfgBXgBXoAX4EV4EV6EF+FFeBFehBfhRXgRXoKX4CV4CV6Cl+AleAlegpfgkTGakCasidXEaSKaeE2CJlETlUllUplUJpVJZVKZVCaVSWVSmVVmlVllVplVZpUvW+f8O/XdTn27Gjo8Z2yP4/rhsePwZ69X9MFkP+3W3eY4deeNe7mWt/Jf","file_map":{"50":{"source":"use poseidon::poseidon2;\n\nmod merkle_root;\n\nfn main(\n    // public inputs\n    root: pub Field,\n    nullifierHash: pub Field,\n    receipient: pub Field,\n    // private inputs\n    secret: Field,\n    nullifier: Field,\n    merkle_proofs: [Field; 20],\n    is_even: [bool; 20],\n) {\n    // compute the commitment\n    let commitment: Field = poseidon2::Poseidon2::hash([nullifier, secret], 2);\n\n    // veriify the nullifierHash\n    let generatedNullifierHash: Field = poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(generatedNullifierHash == nullifierHash);\n\n    // verify the root\n    let computedMerkleRoot: Field =\n        merkle_root::compute_merkle_root(commitment, merkle_proofs, is_even);\n    assert(computedMerkleRoot == root);\n\n    let binding_address = receipient * receipient;\n    assert(binding_address == receipient * receipient)\n}\n","path":"/Users/lakshmi.sanikommu/Desktop/Lucky/zk-mixer/circuits/src/main.nr"},"51":{"source":"use poseidon::poseidon2;\n\npub fn compute_merkle_root(leaf: Field, merkle_proofs: [Field; 20], is_even: [bool; 20]) -> Field {\n    let mut hash = leaf;\n\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proofs[i])\n        } else {\n            (merkle_proofs[i], hash)\n        };\n        hash = poseidon2::Poseidon2::hash([left, right], 2);\n    }\n    hash\n}\n","path":"/Users/lakshmi.sanikommu/Desktop/Lucky/zk-mixer/circuits/src/merkle_root.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/lakshmi.sanikommu/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"}},"names":["main"],"brillig_names":[]}